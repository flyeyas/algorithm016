### 递归

#### 特性，参照
1、向下进入不同的递归层，向上回到原来的层，不能跳跃，必须一层一层的向下或者返回
2、使用参数传递不同层之间的传递变量
3、每一层的环境和周围都是一份新的拷贝，参数穿越不同的层: 发生和携带变化

#### 思维要点
1、不能人肉递归（经常出现的问题，每次第一反应就是人肉递归，需要改变）
2、找到最近最简解决方法，拆分为重复子问题
3、数学归纳法： 最开始最简单的问题成立，推导出后面的重复问题也是成立的。 例子：当n=1成立时，推导出n=2,n=3...也是成立的


#### 代码模板
```
# python
def recursion(level, param1, param2, ...): 
    # 终止递归
    if level > MAX_LEVEL: 
	   process_result 
	   return 
    # 递归主逻辑
    process(level, data...) 
    # 向下递归
    self.recursion(level + 1, p1, ...) 

    # 反转当前状态（在需要时）
```

```
// java
public void recur(int level, int param) { 
  // 终止递归
  if (level > MAX_LEVEL) { 
    // process result 
    return; 
  }
  // 主逻辑
  process(level, param); 
  // 向下递归
  recur( level: level + 1, newParam); 

  // 反转当前状态（如果有需要）
 
}
```




### 题解思路

#### 关于递归要点
抛弃人肉递归，寻找重复性，拆解为重复子问题

#### 括号生成
思路：
1. 输出所有可能性组合
2. 寻找重复性,对称性:
    1. 左侧括号必须要有一个对称的右侧括号，
    2. 左侧括号数量==右侧括号数量，即生成的字符串是一个2n的长度
    3. 每次递归，需要左括号数量 < n, 有括号数量 < 左括号数量